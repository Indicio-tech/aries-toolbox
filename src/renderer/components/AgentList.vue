<template>
  <el-row>
    <nav class="navbar navbar-expand-lg navbar-light bg-light">
      <a class="navbar-brand" href="#">Aries Toolbox</a>
    </nav>

    <el-card shadow="never" class="agent-card" v-for="a in agent_list" v-bind:key="a.id">
      <span slot="header"><strong>{{a.label}}</strong></span>
      <div>
        <div v-show="a.active_as_mediator" class="mediator">Mediator</div>
        <el-button type="text" @click="openConnection(a)">Open</el-button>
        <el-button type="text" @click="deleteConnection(a)">Delete</el-button>
      </div>
    </el-card>

    <el-card shadow="never" class="function_card" id="new_agent_connection">
      <span slot="header">New Agent Connection</span>
      <div>
        <el-form :inline="true">
          <el-input v-model="new_agent_invitation" placeholder="Paste agent invitation"></el-input>
          <el-button type="primary" @click="new_agent_invitation_process">Connect</el-button>
        </el-form>
      </div>
      <el-alert v-show="invitation_error != ''"
        title="Invitation Error"
        type="error"
        :description="invitation_error"
        show-icon>
      </el-alert>
    </el-card>
    <el-card shadow="never" class="function_card" id="new_agent_invitation" v-show="hasMediator">
      <span slot="header">New Agent Invitation</span>
      <div>
        <el-form :inline="true">
          <el-input v-model="new_invitation_label" placeholder="Label"></el-input>
          <el-button type="primary" @click="generate_invitation">Generate</el-button>
        </el-form>
      </div>
      <el-alert v-show="invitation_error != ''"
        title="Invitation Error"
        type="error"
        :description="invitation_error"
        show-icon>
      </el-alert>
    </el-card>
  </el-row>
</template>

<script>
const electron = require('electron');
const bs58 = require('bs58');
const rp = require('request-promise');
const DIDComm = require('encryption-envelope-js');
//import DIDComm from 'didcomm-js';
import { mapState, mapActions, mapGetters } from "vuex"
import { new_connection } from '../connection_detail.js';
import { base64_decode, base64_encode } from '../base64.js';
import { from_store } from '../connection_detail.js';
const uuidv4 = require('uuid/v4');

export default {
  name: 'agent-list',
  components: {  },
  computed: {
    ...mapState("Agents", ["agent_list"]),
    ...mapGetters("Agents", ["get_agent"]),
    hasMediator: function(){
      return this.agent_list.find(a => a.active_as_mediator === true);
    }
  },
  watch: {
    agent_list(newValue, oldValue) {
      console.log(`Updating from ${oldValue} to ${newValue}`);

      // Do whatever makes sense now
      let mediator_agent = newValue.find(a => a.active_as_mediator === true);
      if (mediator_agent) {
        this.mediatorConnect();
      }
    },
  },
  methods: {
    ...mapActions("Agents", ["add_agent", "delete_agent"]),

    openConnection: async function(a) {
      const modalPath = process.env.NODE_ENV === 'development'
        ? 'http://localhost:9080/#/agent/'+a.id
        : `file://${__dirname}/index.html#agent/`+a.id;
      let win = new electron.remote.BrowserWindow({ width: 1000, height: 600, webPreferences: {webSecurity: false, nodeIntegration: true} })
      // TODO: Get the close handler to work to keep track of open windows only
      win.on('close', function () {
        win = null;
        delete this.agent_windows[a.id];
      });
      win.loadURL(modalPath);
      let window_key = a.my_key_b58.publicKey;
      this.agent_windows[window_key] = win;

    },
    deleteConnection: async function(a){
      this.delete_agent(a);
    },
    mediatorConnect: async function(){
      let vm = this; //hold reference

      let mediator_agent = this.agent_list.find(a => a.active_as_mediator === true);
      if(mediator_agent == null) {
        return; //no connection needed
      }
      let mediator_agent_id = mediator_agent.id;

      //this.mediator_connection_loaded = (async () => {
        let agent_info = await this.get_agent(mediator_agent_id);//(mediator_agent_id);
        this.mediator_connection = from_store(agent_info);
      //})();
      //await this.mediator_connection_loaded;
      this.mediator_connection.enable_return_route();
      this.mediator_connection.unpacked_processor = this.mediatorInbound;
      //start poll timer
      if(this.mediator_connection.needs_return_route_poll()){
        this.return_route_poll_timer = setInterval(this.return_route_poll, 10000);
      }
      //TODO: open connection?
      this.mediator_connection.send_message({
        "@type": "did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/trust_ping/1.0/ping",
        "response_requested": false
      });
      console.log("mediator connected", this.mediator_connection);

    },
    mediatorInbound: async function(packed_msg){
      console.log("mediator inbound message", packed_msg);
      let recipients = await this.mediator_connection.extract_packed_message_recipients(packed_msg);
      console.log("inbound message recipients", recipients);
      // TODO: get inbound message to proper agent window. this needs to happen even if window not open.
      // store message
      let message_uuid = uuidv4();

      // send message
      let window_key = recipients[0];
      // TODO: detect lack of open window.
      this.agent_windows[window_key].webContents.send("inbound_message", {
        id: message_uuid,
        recipient: recipients[0],
        msg: packed_msg
      })
    },
    mediatorCleanup: function(){
      if(this.mediator_connection.needs_return_route_poll()) {
        clearInterval(this.return_route_poll_timer)
      }
    },
    generate_invitation: function(){

    },
    async new_agent_invitation_process(){
      //process invite, prepare request
      var vm = this; //hang on to view model reference
      console.log("invite", this.new_agent_invitation);
      this.invitation_error = "";
      //extract c_i param
      function getUrlVars(url) {
        var vars = {};
        var parts = url.replace(/[?&]+([^=&]+)=([^&]*)/gi, function(m,key,value) {
          vars[key] = value;
        });
        return vars;
      }

      var invite_b64 = getUrlVars(this.new_agent_invitation)["c_i"];
      console.log("invite b64", invite_b64);
      //base 64 decode
      var invite_string = base64_decode(invite_b64);
      console.log("invite string", invite_string);
      var invite = JSON.parse(invite_string);
      console.log("invite", invite);

      //make a did
      const didcomm = new DIDComm.DIDComm();
      await didcomm.Ready;
      const toolbox_did = await didcomm.generateKeyPair();
      toolbox_did.did = bs58.encode(Buffer.from(toolbox_did.publicKey.subarray(0, 16)));
      toolbox_did.publicKey_b58 = bs58.encode(Buffer.from(toolbox_did.publicKey));
      toolbox_did.privateKey_b58 = bs58.encode(Buffer.from(toolbox_did.privateKey));
      console.log("new pair", toolbox_did);

      var req = {
        "@id":  (uuidv4().toString()),
        "~transport": {
          "return_route": "all"
        },
        "@type": "did:sov:BzCbsNYhMrjHiqZDTUASHg;spec/connections/1.0/request",
        "label": "ToolBox",
        "connection": {
          "DID": toolbox_did.did,
          "DIDDoc": {
            "@context": "https://w3id.org/did/v1",
            "id": toolbox_did.did,
            "publicKey": [{
              "id": toolbox_did.did + "#keys-1",
              "type": "Ed25519VerificationKey2018",
              "controller": toolbox_did.did,
              "publicKeyBase58": toolbox_did.publicKey_b58
            }],
            "service": [{
              "id": toolbox_did.did + ";indy",
              "type": "IndyAgent",
              "recipientKeys": [toolbox_did.publicKey_b58],
              //"routingKeys": ["<example-agency-verkey>"], // TODO: Use routing keys and endpoint if mediator configured.
              "serviceEndpoint": ""
            }]
          }
        }
      };
      console.log("Exchange Request", req);

      //send request, look for response
      const packedMsg = await didcomm.packMessage(JSON.stringify(req), [bs58.decode(invite.recipientKeys[0])], toolbox_did, true);
      console.log("Packed Exchange Request", packedMsg);

      //send request
      var options = {
        method: 'POST',
        uri: invite.serviceEndpoint,
        body: packedMsg,
      };

      // this code assumes that the response comes via return-route on the post.
      rp(options)
        .then(async function (parsedBody) {
          // POST succeeded...
          //console.log("request post response", parsedBody);
          const unpackedResponse = await didcomm.unpackMessage(parsedBody, toolbox_did);
          //console.log("unpacked", unpackedResponse);
          const response = JSON.parse(unpackedResponse.message);
          //console.log("response message", response);
          //TODO: Validate signature against invite.
          //console.log("connection sig b64 data", response['connection~sig'].sig_data);
          let buff = Buffer.from(response['connection~sig'].sig_data, 'base64');
          let text = buff.toString('ascii');
          //first 8 chars are a timestamp for the signature, so we ignore those before parsing value
          response.connection = JSON.parse(text.substring(8));
          console.log("response message", response);
          //TODO: record endpoint and recipient key in connection record, along with my keypair. use invitation label
          let connection_detail = new_connection(invite.label, response.connection.DIDDoc, toolbox_did);
          console.log("connection detail", connection_detail);
          vm.add_agent(connection_detail.to_store());
          vm.new_agent_invitation = ""; //clear input for next round
        })
        .catch(function (err) {
          // POST failed...
          console.log("request post err", err);
          this.invitation_error = err.message;
        });
    },

  },
  created: async function(){
    this.mediatorConnect();
  },
  beforeDestory: function(){
    this.mediatorCleanup();
  },
  data() {
    return {
      new_agent_invitation: "",
      invitation_error: "",
      new_invitation_label: "",
      agent_windows: {},
    }

  }
}
</script>

<style>
.agent-card:first-of-type {
  margin-top: .5em;
}
.agent-card, .function_card {
  margin: .5em 1em;
  border: 1px solid rgba(0, 0, 0, 0.125);
}
.agent-card .el-card__header,
.function_card .el-card__header {
  padding: .75rem 1.25rem;
  background-color: rgba(0, 0, 0, 0.03);
  border-bottom: 1px solid rgba(0, 0, 0, 0.125);
}
.agent-card .el-card__body {
  padding: 0 1em;
}
  .mediator {
    font-size: .9em;
    font-style: italic;
    text-align: right;
    float:right;
    margin-top: 10px;
  }
</style>
